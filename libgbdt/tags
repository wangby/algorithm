!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.5.4	//
BUFFER_LENGTH	gradient_boosting.h	27;"	d
GBDT_INTERIOR	gradient_boosting.h	17;"	d
GBDT_TERMINAL	gradient_boosting.h	15;"	d
GBDT_TOSPLIT	gradient_boosting.h	16;"	d
LOG_ERROR_	gradient_boosting.h	31;"	d
LOG_NOTICE_	gradient_boosting.h	33;"	d
LOG_WARNING_	gradient_boosting.h	32;"	d
NO_VALUE	gradient_boosting.h	29;"	d
NUMERIC	gradient_boosting.cpp	1414;"	d	file:
R_qsort_I	gradient_boosting.cpp	/^void R_qsort_I(double *v, int *I, int i, int j)$/;"	f
SAMPLE_RATIO	gradient_boosting.h	25;"	d
SAMPLE_TYPE	gradient_boosting.h	24;"	d
_SO_API_	gbdt_rabbit.cpp	24;"	d	file:
_SO_API_	gbdt_rabbit.cpp	30;"	d	file:
bestid	gradient_boosting.h	/^	int bestid; \/\/!< 分裂使用的Feature ID$/;"	m
bestsplit	gradient_boosting.h	/^ 	double bestsplit; \/\/!< 分裂边界的x值$/;"	m
bufset	gradient_boosting.h	/^} bufset; \/\/!< 训练数据池$/;"	t
critparent	gradient_boosting.h	/^ 	double critparent; \/\/!< 分裂的评价值$/;"	m
data_num	gradient_boosting.h	/^ 	int data_num; \/\/!< 训练数据的数据量$/;"	m
depth	gradient_boosting.h	/^ 	int* depth; \/\/ 节点深度$/;"	m
fea_num	gradient_boosting.h	/^ 	int fea_num; \/\/!< Feature的数量$/;"	m
fea_pool	gradient_boosting.h	/^	int* fea_pool; \/\/!< 随机 feature 候选池$/;"	m
feature_average	gradient_boosting.h	/^	double* feature_average; \/\/!< Feature在训练数据的平均值$/;"	m
fill_no_value_aver	gbdt_rabbit.cpp	/^  void fill_no_value_aver(gbdt_model_t* gbdt_model, double* x_test)$/;"	f
fill_no_value_aver	gbdt_test.cpp	/^void fill_no_value_aver(gbdt_model_t* gbdt_model, double* x_test)$/;"	f
fill_novalue_feature	gradient_boosting.cpp	/^int fill_novalue_feature(double* x, int fea_num, int data_num, double* faverage)$/;"	f
filter_query	gbdt_rabbit.cpp	/^  _SO_API_(int) filter_query(char * query)$/;"	f
free_model	gradient_boosting.cpp	/^int free_model(gbdt_model_t*& gbdt_model)$/;"	f
fv	gradient_boosting.h	/^ 	double* fv; \/\/!< 特征值排序用的buffer版本$/;"	m
fvalue_list	gradient_boosting.h	/^ 	double* fvalue_list; \/\/!< 以feature i 为拉链的特征值 x_i$/;"	m
gbdt_info_t	gradient_boosting.h	/^} gbdt_info_t; \/\/!< 模型配置参数的结构体$/;"	t
gbdt_load_model	gradient_boosting.cpp	/^gbdt_model_t* gbdt_load_model(char* model_file)$/;"	f
gbdt_load_reg_forest	gradient_boosting.cpp	/^int gbdt_load_reg_forest(FILE* model_fp, gbdt_model_t* gbdt_model)$/;"	f
gbdt_max_depth	gradient_boosting.h	/^ 	int gbdt_max_depth; \/\/!< 树停止的条件，树的深度$/;"	m
gbdt_min_node_size	gradient_boosting.h	/^ 	int gbdt_min_node_size; \/\/!< 树停止的条件，节点覆盖的最少的数据量$/;"	m
gbdt_model_t	gradient_boosting.h	/^}gbdt_model_t; \/\/!< GBDT模型的结构体$/;"	t
gbdt_regression_predict	gradient_boosting.cpp	/^int gbdt_regression_predict(gbdt_model_t* gbdt_model, double *x_test, double& ypredict)$/;"	f
gbdt_regression_train	gradient_boosting.cpp	/^gbdt_model_t* gbdt_regression_train(double *x_fea_value, double *y_result_score, gbdt_info_t infbox)$/;"	f
gbdt_save_model	gradient_boosting.cpp	/^int gbdt_save_model(gbdt_model_t* gbdt_model, char* model_filename)$/;"	f
gbdt_save_reg_forest	gradient_boosting.cpp	/^int gbdt_save_reg_forest(FILE* model_fp, gbdt_tree_t** reg_forest, gbdt_info_t infbox)$/;"	f
gbdt_single_tree_estimation	gradient_boosting.cpp	/^int gbdt_single_tree_estimation(double *x_fea_value, double *y_gradient, $/;"	f
gbdt_tree_node_split	gradient_boosting.cpp	/^int gbdt_tree_node_split(gbdt_info_t gbdt_inf, bufset* data_set, double *x_fea_value, double *y_score,$/;"	f
gbdt_tree_predict	gradient_boosting.cpp	/^int gbdt_tree_predict(double *x_test, gbdt_tree_t *gbdt_single_tree, double& ypred, double shrink)$/;"	f
gbdt_tree_t	gradient_boosting.h	/^} gbdt_tree_t; \/\/!< 回归树的结构体$/;"	t
has_colon	gbdt_test.cpp	/^bool has_colon(string item)$/;"	f
has_colon	gbdt_train.cpp	/^ bool has_colon(string item)$/;"	f
hmap	gbdt_rabbit.cpp	/^ typedef map <string,string> hmap;\/\/\/@brief the rabbit result type define$/;"	t	file:
index_b	gradient_boosting.h	/^	int index_b; \/\/!< 节点覆盖数据的开始$/;"	m
index_e	gradient_boosting.h	/^ 	int index_e; \/\/!< 节点覆盖数据的结束$/;"	m
info	gradient_boosting.h	/^	gbdt_info_t info; \/\/!< GBDT的配置参数$/;"	m
init_info	gradient_boosting.cpp	/^int init_info(gbdt_info_t& infbox)$/;"	f
items	gbdt_rabbit.cpp	/^   string* items;$/;"	m	struct:thread_para	file:
load_gbdt_info	gradient_boosting.cpp	/^int load_gbdt_info(gbdt_info_t* pinfbox, FILE* model_fp)$/;"	f
lson	gradient_boosting.h	/^ 	int* lson; \/\/!< 节点的左儿子$/;"	m
main	gbdt_test.cpp	/^int main(int argc, char* argv[])$/;"	f
main	gbdt_train.cpp	/^int main(int argc, char* argv[])$/;"	f
main_thread_des	gbdt_rabbit.cpp	/^ _SO_API_(void) main_thread_des(void * arg)$/;"	f
main_thread_init	gbdt_rabbit.cpp	/^ _SO_API_(int) main_thread_init(Ul_confdata * conf)$/;"	f
max_feature_label	gradient_boosting.cpp	/^int max_feature_label(string line)$/;"	f
model_filename	gradient_boosting.h	/^ 	char model_filename[BUFFER_LENGTH]; \/\/!< 模型文件名$/;"	m
my_memset	gbdt_train.cpp	/^void my_memset(double* x, int count, int value)$/;"	f
ndavg	gradient_boosting.h	/^ 	double* ndavg; \/\/!< 节点内元素的均值$/;"	m
ndcount	gradient_boosting.h	/^ 	int* ndcount; \/\/!< 节点内元素的个数$/;"	m
ndstart	gradient_boosting.h	/^ 	int* ndstart; \/\/!< 节点对应于 Index 的开始位置$/;"	m
nodeinfo	gradient_boosting.h	/^} nodeinfo; \/\/!< 节点的信息$/;"	t
nodenum	gradient_boosting.h	/^ 	int nodenum; \/\/!< 节点覆盖的数据量$/;"	m
nodesize	gradient_boosting.h	/^ 	int nodesize; \/\/!< 树的节点个数$/;"	m
nodestatus	gradient_boosting.h	/^	int* nodestatus; \/\/!< 节点状态 待split, 中间节点, 终结点$/;"	m
nodesum	gradient_boosting.h	/^ 	double nodesum; \/\/!< 节点覆盖的数据y值的和，回归用$/;"	m
order_i	gradient_boosting.h	/^ 	int* order_i; \/\/!< 排序的标号$/;"	m
ori	gbdt_rabbit.cpp	/^   char ori[BUFFER_LENGTH];$/;"	m	struct:thread_para	file:
pivot	gradient_boosting.h	/^ 	int pivot; \/\/!< 分裂边界的数据标号$/;"	m
print_usage	gradient_boosting.cpp	/^int print_usage (FILE* stream, char* program_name)$/;"	f
process_result	gbdt_rabbit.cpp	/^  _SO_API_(int) process_result(void * arg, hmap *result,void * selfswitch)$/;"	f
qsort_Index	gradient_boosting.cpp	1413;"	d	file:
rand_fea_num	gradient_boosting.h	/^ 	int rand_fea_num; \/\/!< Feature的采样数量$/;"	m
read_conf_file	gradient_boosting.cpp	/^int read_conf_file(gbdt_info_t& infbox, int argc, char* argv[])$/;"	f
read_train_file	gbdt_train.cpp	/^int read_train_file(double*& x, double*& y, gbdt_info_t infbox)$/;"	f
reg_forest	gradient_boosting.h	/^	gbdt_tree_t** reg_forest; \/\/!< 回归森林$/;"	m
rson	gradient_boosting.h	/^ 	int* rson; \/\/!< 节点的右儿子$/;"	m
sample_num	gradient_boosting.h	/^ 	int sample_num; \/\/!< 训练数据的采样量$/;"	m
save_gbdt_info	gradient_boosting.cpp	/^int save_gbdt_info(gbdt_info_t infbox, FILE* model_fp)$/;"	f
shrink	gradient_boosting.h	/^ 	double shrink; \/\/!< 学习率$/;"	m
splitid	gradient_boosting.h	/^ 	int* splitid; \/\/!< 节点对应的split特征$/;"	m
splitinfo	gradient_boosting.h	/^} splitinfo; \/\/!< 分裂的信息$/;"	t
splitline	gradient_boosting.cpp	/^int splitline(string line, string items[], int items_num, const char separator)$/;"	f
splitvalue	gradient_boosting.h	/^ 	double* splitvalue; \/\/!< split特征对应的split value$/;"	m
swap_int	gradient_boosting.h	22;"	d
thread_para	gbdt_rabbit.cpp	/^ typedef struct thread_para$/;"	s	file:
thread_para_t	gbdt_rabbit.cpp	/^ }thread_para_t;$/;"	t	file:
thread_resource_des	gbdt_rabbit.cpp	/^  _SO_API_(void) thread_resource_des(void * arg)$/;"	f
thread_resource_init	gbdt_rabbit.cpp	/^  _SO_API_(void) * thread_resource_init(int count , int arg[])$/;"	f
thread_run	gbdt_rabbit.cpp	/^  _SO_API_(void *) thread_run(char* line,void * parg, $/;"	f
train_filename	gradient_boosting.h	/^ 	char train_filename[BUFFER_LENGTH]; \/\/!< 训练样本的文件名$/;"	m
tree_num	gradient_boosting.h	/^	int tree_num; \/\/!< 森林树的个数$/;"	m
uint32	gradient_boosting.h	21;"	d
x_test	gbdt_rabbit.cpp	/^   double* x_test;$/;"	m	struct:thread_para	file:
y_list	gradient_boosting.h	/^ 	double* y_list; \/\/!< 回归的y值集合$/;"	m
y_reg_predict	gbdt_rabbit.cpp	/^   double y_reg_predict;$/;"	m	struct:thread_para	file:
